use std::{fs::File, io::Write, path::PathBuf};

use c_types::{CByteArrayType, CIntegerStdintH, FormatToCType};
use clang::*;

use clap::Parser;
use color_eyre::{
    Result, Section,
    eyre::{OptionExt, bail, ensure, eyre},
};
use log::{debug, warn};

mod c_types;

const TOOL_NAME: &str = env!("CARGO_BIN_NAME");
const TOOL_VERSION: &str = env!("CARGO_PKG_VERSION");

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Whether to perform an endianness swap
    ///
    /// If this flag is not set, endianness is never changed.
    /// If this flag is set, endianness of all primitive types longer than 1 byte is swapped.
    #[arg(short, long)]
    endianness_swap: bool,

    /// Whether to add inline to function declaration
    ///
    /// If this flag is not set, inline is not added to function declaration.
    /// If this flag is set, inline is added to function declaration.
    #[arg(short, long)]
    inline: bool,

    /// Whether to create the header instead of source file.
    ///
    /// If this flag is not set, the header file is generated.
    /// If this flag is set, the source file is generated.
    #[arg(short, long)]
    gen_source: bool,

    /// Input C file to consume
    ///
    /// Can be either a .c or a .h file.
    input_file: PathBuf,

    /// Output C file
    ///
    /// If not specified, instead the generated code is printed to the terminal's stdout
    #[arg(short, long)]
    output_file: Option<PathBuf>,

    /// Clang arguments
    ///
    /// These are passed through verbatim to (lib-)clang. Likely you want to set the target architecture here, e.g.
    ///
    /// -- --target=wasm32-unknown-none
    clang_args: Vec<String>,
}

fn main() -> Result<()> {
    // parse the CLI arguments
    let args = Cli::parse();

    // intialize logger
    colog::init();
    color_eyre::install()?;

    debug!("initializing clang");
    let clang = Clang::new().map_err(|e| eyre!("error initializing clang:\n{e}"))?;

    // Create a new `Index`
    let index = Index::new(&clang, false, false);

    // Parse a source file into a translation unit
    let mut parser = index.parser(&args.input_file);

    // Pass all clang args
    parser.arguments(&args.clang_args);

    // parse the code into a translation unit
    debug!("parsing {:?}", args.input_file);
    let tu = parser.parse()?;

    // get target information
    let target = tu.get_target();
    debug!("target: {target:?}");
    let Target {
        triple: target_triple,
        pointer_width: _target_pointer_width,
    } = target;

    // Get the structs in this translation unit
    let structs = tu
        .get_entity()
        .get_children()
        .into_iter()
        .filter(|e| e.get_kind() == EntityKind::StructDecl)
        .collect::<Vec<_>>();

        for struct_ in &structs {
            let name = struct_.get_name().unwrap_or("<anonymous>".to_string());
            let type_ = struct_.get_type().unwrap();
            let size = type_.get_sizeof().unwrap_or(0);
            println!("struct {} (size: {} bytes)", name, size);

            for field in struct_.get_children() {
                let field_name = field.get_name().unwrap_or("<anon>".to_string());
                let offset = type_.get_offsetof(&field_name).unwrap_or(usize::MAX);
                println!("  field: {} (offset: {} bits)", field_name, offset);
            }
        }

    let mut c_code_snippets = Vec::new();

    c_code_snippets.push(format!(
        "\
        // THIS CODE IS AUTOGENERATED, DON'T MODIFY BY HAND\n\
        //\n\
        // This library provides access to data type instances represented in\n\
        // a foreign architecture's ABI. In particular, it provides getter and setter\n\
        // functions for struct fields which observe the foreign architecture's memory\n\
        // layout.\n\
        //\n\
        // input_file ..... {:?}\n\
        // clang_args ..... {:?}\n\
        // target_arch .... {target_triple}\n\
        // generated_by ... {TOOL_NAME} v{TOOL_VERSION}\n\n\n\
        #include<stdint.h>\n\
        ",
        args.input_file, args.clang_args
    ));

    // if endianness swap is desired, include the header file for it
    if args.endianness_swap {
        c_code_snippets.push("#include<byteswap.h>".into());
    }

    c_code_snippets.push("\n\n".into());

    // Print information about the structs
    for struct_ in structs {
        let struct_ty = struct_.get_type().ok_or_eyre("struct type is unknown?!")?;
        let struct_size_bytes = struct_ty.get_sizeof()?;
        let struct_name = struct_.get_name().ok_or_eyre("struct has no name")?;
        debug!(
            "struct: {:?} (size: {} bytes)",
            struct_.get_name().unwrap(),
            struct_size_bytes
        );

        // code gen boilerplate
        let mut prefix = "";
        if args.inline {
            prefix = "inline ";
        }
        let namespace_prefix = "camw";
        let function_name_gen = |op| format!("{namespace_prefix}_{op}__{struct_name}");

        // section header for this struct
        let section_title = format!(" {struct_name} ");
        c_code_snippets.push(format!("/*{section_title:*^76}*/"));
        c_code_snippets.push("\n".into());

        let function_name = function_name_gen("sizeof");
        // helper functions for size of the entire struct
        if args.gen_source {
            c_code_snippets.push(format!(
                "\
                // `sizeof({struct_name})`\n\
                //\n\
                // Returns the size in bytes consumed for one instance of the `{struct_name}`\n\
                {prefix}uintptr_t {function_name}(){{\n\
                \treturn {struct_size_bytes};\n\
                }}\n\
                "
            ));
        }
        else {
            c_code_snippets.push(format!(
                "\
                // `sizeof({struct_name})`\n\
                //\n\
                // Returns the size in bytes consumed for one instance of the `{struct_name}`\n\
                uintptr_t {function_name}();\n\
                "
            ));
        }

        c_code_snippets.push("\n\n".into());

        for struct_field in struct_.get_children() {
            ensure!(
                struct_field.get_kind() == EntityKind::FieldDecl,
                "all fields of a struct must be of FieldDecl type"
            );

            // note down the origin of this error
            let error_note = format!("struct {struct_name:?}, field {struct_field:?}");

            let field_name = struct_field
                .get_name()
                .ok_or_eyre("unknown name")
                .section(error_note.clone())?;

            let field_offset_bits = struct_ty
                .get_offsetof(&field_name)
                .map_err(|e| eyre!("unknown offset").error(e).section(error_note.clone()))?;

            let field_ty = struct_field
                .get_type()
                .ok_or_eyre("uknown type")
                .section(error_note.clone())?;

            println!(
                "    field: {:?} (offset: {} bits)",
                field_name, field_offset_bits
            );

            let new_c_code_snippets = generate_getter_setter(
                &struct_name,
                &field_name,
                field_offset_bits,
                field_ty,
                args.endianness_swap,
                args.inline,
                args.gen_source,
            )?;

            c_code_snippets.push(new_c_code_snippets.join("\n\n"));
            c_code_snippets.push("\n\n".into());
        }
    }

    debug!("done generating code, writing output");

    for string in &mut c_code_snippets {
        // re-tab with spaces
        let spaces_per_tab = 2;
        let tab_space_replacement = " ".repeat(spaces_per_tab);
        *string = string.replace('\t', &tab_space_replacement);

        if !string.ends_with("\n") {
            string.push('\n');
        }
    }

    let final_c_code = c_code_snippets.concat();

    match args.output_file {
        // write to output file
        Some(output_file) => {
            let mut file = File::create(output_file)?;
            file.write_all(final_c_code.as_bytes())?;
        }
        // write to stdout
        None => println!("{final_c_code}"),
    }

    Ok(())
}

fn generate_getter_setter(
    struct_name: &str,
    field_name: &str,
    offset_bits: usize,
    ty: clang::Type,
    swap_endianness: bool,
    inline: bool,
    gen_source: bool,
) -> Result<Vec<String>> {
    if offset_bits % 8 != 0 {
        bail!("bit offset which is not devisable by 8, this is not implemented yet");
    }

    let offset_bytes = offset_bits / 8;

    let mut c_code_snippets = Vec::new();

    let mut prefix = "";
    if inline {
        prefix = "inline ";
    }
    let namespace_prefix = "camw";
    let function_name_gen = |op| format!("{namespace_prefix}_{op}__{struct_name}__{field_name}");
    let u8 = "uint8_t";

    let type_formatter: Box<dyn FormatToCType>;

    // desugar this type so that we know what it actually is
    let canonical_type = ty.get_canonical_type();

    let section_title = format!(" {struct_name}.{field_name} ");
    c_code_snippets.push(format!("/*{section_title:*^76}*/"));

    use TypeKind::*;
    match (canonical_type.get_kind(), canonical_type.get_element_type()) {
        // integer or float or pointer
        (
            CharS | CharU | SChar | UChar | Short | UShort | Int | UInt | Long | ULong | LongLong
            | ULongLong | Float | Double | Pointer | Enum,
            _,
        ) => {
            type_formatter = Box::new(CIntegerStdintH::new(canonical_type)?);
            let return_type = type_formatter.to_function_return_type();
            let argument_type = type_formatter.to_function_argument_type("value");

            if swap_endianness {
                let size_of_type_bytes = type_formatter.size_bytes();
                let byte_swap_fn = match size_of_type_bytes {
                    1 => "".to_string(),
                    n @ 2 | n @ 4 | n @ 8 => format!("bswap_{}", 8 * n),
                    n => {
                        bail!(
                            "unable to perform a byte swap for an integer that is is {n} bytes wide"
                        )
                    }
                };

                let function_name = function_name_gen("get");
                // getter for integer types
                if gen_source {
                    c_code_snippets.push(format!("\
                        // Get `{struct_name}.{field_name}`\n\
                        //\n\
                        // Returns the field `{field_name}`'s value from an instance of the `{struct_name}` struct, with endianness swapped\n\
                        {prefix}{return_type} {function_name}({u8} * struct_base_addr) {{\n\
                        \t{return_type} return {byte_swap_fn}(*({return_type}*)(struct_base_addr + {offset_bytes}));\n\
                        }}"));
                } else {
                    c_code_snippets.push(format!("\
                        // Get `{struct_name}.{field_name}`\n\
                        //\n\
                        // Returns the field `{field_name}`'s value from an instance of the `{struct_name}` struct, with endianness swapped\n\
                        {function_name}({u8} * struct_base_addr);"));
                }

                let function_name = function_name_gen("set");
                // setter for integer types
                if gen_source {
                    c_code_snippets.push(format!("\
                        // Set `{struct_name}.{field_name}` to `value`\n\
                        // \n\
                        // Overwrites the field `{field_name}`'s value of an `{struct_name}` struct instance with `value`, with endianness swapped\n\
                        {prefix}void {function_name}({u8} * struct_base_addr, {argument_type}) {{\n\
                        \t*(struct_base_addr + {offset_bytes}) = {byte_swap_fn}(value);\n\
                        }}"));
                } else {
                    c_code_snippets.push(format!("\
                        // Set `{struct_name}.{field_name}` to `value`\n\
                        // \n\
                        // Overwrites the field `{field_name}`'s value of an `{struct_name}` struct instance with `value`, with endianness swapped\n\
                        void {function_name}({u8} * struct_base_addr, {argument_type});"));
                }
            } else {
                let function_name = function_name_gen("get");
                // getter for integer types
                if gen_source {
                    c_code_snippets.push(format!("\
                        // Get `{struct_name}.{field_name}`\n\
                        //\n\
                        // Returns the field `{field_name}`'s value from an instance of the `{struct_name}` struct\n\
                        {prefix}{return_type} {function_name}({u8} * struct_base_addr) {{\n\
                        \treturn *({return_type}*)(struct_base_addr + {offset_bytes});\n\
                        }}"));
                } else {
                    c_code_snippets.push(format!("\
                        // Get `{struct_name}.{field_name}`\n\
                        //\n\
                        // Returns the field `{field_name}`'s value from an instance of the `{struct_name}` struct\n\
                        {return_type} {function_name}({u8} * struct_base_addr);"));
                }

                let function_name = function_name_gen("set");
                // setter for integer types
                if gen_source {
                    c_code_snippets.push(format!("\
                        // Set `{struct_name}.{field_name}` to `value`\n\
                        // \n\
                        // Overwrites the field `{field_name}`'s value of an `{struct_name}` struct instance with `value`\n\
                        {prefix}void {function_name}({u8} * struct_base_addr, {argument_type}) {{\n\
                        \t*(struct_base_addr + {offset_bytes}) = value;\n\
                        }}"));
                } else {
                    c_code_snippets.push(format!("\
                        // Set `{struct_name}.{field_name}` to `value`\n\
                        // \n\
                        // Overwrites the field `{field_name}`'s value of an `{struct_name}` struct instance with `value`\n\
                        void {function_name}({u8} * struct_base_addr, {argument_type});"));
                }
            }
        }

        // for arrays whose element type is one byte in size we can just verbatim copy
        (ConstantArray, Some(element_ty)) if element_ty.get_sizeof() == Ok(1) => {
            type_formatter = Box::new(CByteArrayType::new(canonical_type)?);
            let argument_type_dst = type_formatter.to_function_argument_type("dst");
            let argument_type_src = type_formatter.to_function_argument_type("src");
            let size_of_type_bytes = type_formatter.size_bytes();

            let function_name = function_name_gen("read");
            // getter for array types
            if gen_source {
                c_code_snippets.push(format!("\
                    // Read from `{struct_name}.{field_name}`\n\
                    //\n\
                    // Copies from `{field_name}` field of an instance of the `{struct_name}` struct to `destination`\n\
                    {prefix}void {function_name}({u8} * struct_base_addr, {argument_type_dst}) {{\n\
                    \tfor(uintptr_t i = 0; i < {size_of_type_bytes}; i++)\n\
                    \t\tdst[i] = struct_base_addr[{offset_bytes} + i];\n\
                    }}"));
            } else {
                c_code_snippets.push(format!("\
                    // Read from `{struct_name}.{field_name}`\n\
                    //\n\
                    // Copies from `{field_name}` field of an instance of the `{struct_name}` struct to `destination`\n\
                    void {function_name}({u8} * struct_base_addr, {argument_type_dst});"));
            }

            let function_name = function_name_gen("write");
            // setter for array types
            if gen_source {
                c_code_snippets.push(format!("\
                    // Write to `{struct_name}.{field_name}`\n\
                    //\n\
                    // Copies from `source` to the `{field_name}` field of an `{struct_name}` struct instance\n\
                    {prefix}void {function_name}({u8} * struct_base_addr, {argument_type_src}) {{\n\
                    \tfor(uintptr_t i = 0; i < {size_of_type_bytes}; i++)\n\
                    \t\tstruct_base_addr[{offset_bytes} + i] = src[i];\n\
                    }}"));
            } else {
                c_code_snippets.push(format!("\
                    // Write to `{struct_name}.{field_name}`\n\
                    //\n\
                    // Copies from `source` to the `{field_name}` field of an `{struct_name}` struct instance\n\
                    void {function_name}({u8} * struct_base_addr, {argument_type_src});"));
            }
        }

        // TODO for array whose element types are larger than one byte in size, endian-ness swap eacht element
        (Record, _) => {
            // TODO just return a pointer to this records offset
            return Ok(vec![]);
        }

        // we don't know what to do
        x => {
            warn!(
                "don't know how to represent types of \"{x:?}\" kind\n\
                elaborated type:  {ty:?}\n\
                canonical type:   {canonical_type:?}"
            );
            return Ok(vec![]);
        }
    }

    let function_name = function_name_gen("sizeof");
    // helper functions for size of the field
    if gen_source {
        c_code_snippets.push(format!(
            "\
            // sizeof(`{struct_name}->{field_name})`\n\
            //\n\
            // Returns the size in bytes of the `{field_name}` field from the `{struct_name}` struct\n\
            {prefix}uintptr_t {function_name}() {{\n\
            \treturn {};\n\
            }}",
            type_formatter.size_bytes()
        ));
    } else {
        c_code_snippets.push(format!(
            "\
            // sizeof(`{struct_name}->{field_name})`\n\
            //\n\
            // Returns the size in bytes of the `{field_name}` field from the `{struct_name}` struct\n\
            uintptr_t {function_name}();"
        ));
    }

    let function_name = function_name_gen("offsetof");
    // helper functions for offset of the field withing the struct
    if gen_source {
        c_code_snippets.push(format!("\
            // `offsetof({struct_name}, {field_name})`\n\
            //\n\
            // Get the offset in bytes of the `{field_name}` field from the start of a `{struct_name}` struct\n\
            {prefix}uintptr_t {function_name}() {{\n\
            \treturn {offset_bytes};\n\
            }}",
        ));
    } else {
        c_code_snippets.push(format!("\
            // `offsetof({struct_name}, {field_name})`\n\
            //\n\
            // Get the offset in bytes of the `{field_name}` field from the start of a `{struct_name}` struct\n\
            {prefix}uintptr_t {function_name}();",
        ));
    }

    Ok(c_code_snippets)
}
