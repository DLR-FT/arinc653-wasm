use std::{fs::File, io::Write};

use clang::*;

use clap::Parser;
use cli::Cli;
use code_gen::{CInclude, CSection, CSnippet, insert_struct_functions};
use color_eyre::{Result, eyre::eyre};
use log::{debug, error};

mod cli;
mod code_gen;

const TOOL_NAME: &str = env!("CARGO_BIN_NAME");
const TOOL_VERSION: &str = env!("CARGO_PKG_VERSION");

fn main() -> Result<()> {
    // parse the CLI arguments
    let Cli {
        endianness_swap,
        input_file,
        output_file,
        prefix,
        function_decl_prefix,
        comment,
        only_prototype,
        clang_args: clang_args_suffix,
    } = Cli::parse();

    // intialize logger
    colog::init();
    color_eyre::install()?;

    // read additional clang args, prepend the CLI args
    let mut clang_args = c_abi_lens::clang_args_from_env();
    clang_args.extend(clang_args_suffix);

    debug!("initializing clang");
    let clang = Clang::new().map_err(|e| eyre!("error initializing clang:\n{e}"))?;

    // Create a new `Index`
    let index = Index::new(&clang, false, true);

    // Parse a source file into a translation unit
    let mut parser = index.parser(&input_file);

    // Pass all clang args
    debug!("clang args: {clang_args:#?}");
    parser.arguments(&clang_args);

    // parse the code into a translation unit
    debug!("parsing {:?}", input_file);
    let tu = parser.parse()?;

    // get target information
    let target = tu.get_target();
    debug!("target: {target:?}");
    let Target {
        triple: target_triple,
        pointer_width: _target_pointer_width,
    } = target;

    // Get the structs in this translation unit
    let structs = tu
        .get_entity()
        .get_children()
        .into_iter()
        .filter(|e| e.get_kind() == EntityKind::StructDecl)
        .collect::<Vec<_>>();

    let mut code_snippets = Vec::new();

    // section header for the entire library
    code_snippets.push(
        CSection {
            title: " c-abi-lens ".to_owned(),
            comment: format!(
                "\
                THIS CODE IS AUTOGENERATED, DON'T MODIFY BY HAND\n\
                \n\
                This header-only library provides access to data type instances represented in\n\
                a foreign architecture's ABI. In particular, it provides getter and setter\n\
                functions for struct fields which observe the foreign architecture's memory\n\
                layout.\n\
                \n\
                input_file ........... {input_file:?}\n\
                clang_args ........... {clang_args:?}\n\
                target_arch .......... {target_triple}\n\
                prefix ............... {prefix}\n\
                function_decl_prefix . {function_decl_prefix:?}\n\
                emit_comment ......... {comment}\n\
                only_prototype........ {only_prototype}\n\
                generated_by ......... {TOOL_NAME} v{TOOL_VERSION}\n\n\n\
                "
            ),
        }
        .into(),
    );

    // add include of stdint.h
    code_snippets.push(CInclude::System("stdint.h".to_owned()).into());

    // if endianness swap is desired, include the header file for it
    if endianness_swap {
        code_snippets.push(CInclude::System("byteswap.h>".to_owned()).into());
    }

    code_snippets.push(CSnippet::Newline);
    code_snippets.push(CSnippet::Newline);

    // Print information about the structs
    for struct_ in structs {
        if let Err(e) = insert_struct_functions(&mut code_snippets, &struct_, endianness_swap) {
            error!(
                "skipping to the next struct, because the following error occured while generating struct functions:\n{e}"
            )
        }
    }

    code_snippets.push(CSnippet::Newline);

    debug!("done generating code, writing output");

    // assmeble the code
    let section_title_comment_width = 80;
    let spaces_per_tab = 4;

    // actually generate strings
    let mut code_snippet_strings: Vec<String> = code_snippets
        .iter()
        .map(|s| match s {
            CSnippet::Include(cinclude) => cinclude.generate(),
            CSnippet::Func(cfunc) => {
                cfunc.generate(comment, !only_prototype, function_decl_prefix.as_deref())
            }
            CSnippet::Section(csection) => csection.generate(section_title_comment_width),
            CSnippet::Newline => '\n'.into(),
        })
        .collect();

    // retab with spaces
    for snip in &mut code_snippet_strings {
        let tab_space_replacement = " ".repeat(spaces_per_tab);
        *snip = snip.replace('\t', &tab_space_replacement);

        // normalize newline endings
        if !snip.ends_with("\n") {
            snip.push('\n');
        }
    }

    // join it into a string
    let final_c_code = code_snippet_strings.concat();

    match output_file {
        // write to output file
        Some(output_file) => {
            let mut file = File::create(output_file)?;
            file.write_all(final_c_code.as_bytes())?;
        }
        // write to stdout
        None => println!("{final_c_code}"),
    }

    Ok(())
}
