use std::{fs::File, io::Write, path::PathBuf};

use c_types::RepresentableCType;
use clang::*;

use clap::Parser;
use color_eyre::{
    Result, Section,
    eyre::{OptionExt, bail, ensure, eyre},
};
use log::{debug, info};

mod c_types;

const TOOL_NAME: &str = env!("CARGO_BIN_NAME");
const TOOL_VERSION: &str = env!("CARGO_PKG_VERSION");

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Whether to perform an endianness swap
    ///
    /// If this flag is not set, endianness is never changed.
    /// If this flag is set, endianness of all primitive types longer than 1 byte is swapped.
    #[arg(short, long)]
    endianness_swap: bool,

    /// Input C file to consume
    ///
    /// Can be either a .c or a .h file.
    input_file: PathBuf,

    /// Output C file
    ///
    /// If not specified, instead the generated code is printed to the terminal's stdout
    #[arg(short, long)]
    output_file: Option<PathBuf>,

    /// Identifier prefix
    ///
    /// Prefix used before all visible identifiers
    #[arg(short, long, default_value = "cal")]
    prefix: String,

    /// Function declaration prefix
    ///
    /// Set a prefix for function declarition, e.g. `static inline`
    #[arg(short, long)]
    function_decl_prefix: Option<String>,

    /// Emit comment for each function
    ///
    /// If set, each function comes with a doc-comment
    #[arg(short, long)]
    comment: bool,

    /// Only emit prototype/forward declaration for each function
    ///
    /// If set, each function will only be declared but not defined
    #[arg(long)]
    only_prototype: bool,

    /// Clang arguments
    ///
    /// These are passed through verbatim to (lib-)clang. Likely you want to set the target architecture here, e.g.
    ///
    /// -- --target=wasm32-unknown-none
    clang_args: Vec<String>,
}

fn main() -> Result<()> {
    // parse the CLI arguments
    let Cli {
        endianness_swap,
        input_file,
        output_file,
        prefix,
        function_decl_prefix,
        comment,
        only_prototype,
        clang_args,
    } = Cli::parse();

    // intialize logger
    colog::init();
    color_eyre::install()?;

    debug!("initializing clang");
    let clang = Clang::new().map_err(|e| eyre!("error initializing clang:\n{e}"))?;

    // Create a new `Index`
    let index = Index::new(&clang, false, true);

    // Parse a source file into a translation unit
    let mut parser = index.parser(&input_file);

    // Pass all clang args
    parser.arguments(&clang_args);

    // parse the code into a translation unit
    debug!("parsing {:?}", input_file);
    let tu = parser.parse()?;

    // get target information
    let target = tu.get_target();
    debug!("target: {target:?}");
    let Target {
        triple: target_triple,
        pointer_width: _target_pointer_width,
    } = target;

    // Get the structs in this translation unit
    let structs = tu
        .get_entity()
        .get_children()
        .into_iter()
        .filter(|e| e.get_kind() == EntityKind::StructDecl)
        .collect::<Vec<_>>();

    let mut code_snippets = Vec::new();

    // section header for the entire library
    code_snippets.push(
        CSection {
            title: " c-abi-lens ".to_owned(),
            comment: format!(
                "\
                THIS CODE IS AUTOGENERATED, DON'T MODIFY BY HAND\n\
                \n\
                This header-only library provides access to data type instances represented in\n\
                a foreign architecture's ABI. In particular, it provides getter and setter\n\
                functions for struct fields which observe the foreign architecture's memory\n\
                layout.\n\
                \n\
                input_file ........... {input_file:?}\n\
                clang_args ........... {clang_args:?}\n\
                target_arch .......... {target_triple}\n\
                prefix ............... {prefix}\n\
                function_decl_prefix . {function_decl_prefix:?}\n\
                emit_comment ......... {comment}\n\
                only_prototype........ {only_prototype}\n\
                generated_by ......... {TOOL_NAME} v{TOOL_VERSION}\n\n\n\
                "
            ),
        }
        .into(),
    );

    code_snippets.push(CInclude::System("stdint.h".to_owned()).into());

    // if endianness swap is desired, include the header file for it
    if endianness_swap {
        code_snippets.push(CInclude::System("byteswap.h>".to_owned()).into());
    }

    code_snippets.push(CSnippet::Newline);
    code_snippets.push(CSnippet::Newline);

    // Print information about the structs
    for struct_ in structs {
        let struct_type = struct_.get_type().ok_or_eyre("struct type is unknown?!")?;
        let struct_size_bytes = struct_type.get_sizeof()?;

        let struct_name = struct_.get_name().ok_or_eyre("struct has no name")?;
        info!("generating for struct {struct_name:?}");

        debug!("struct: {struct_name:?} (size: {struct_size_bytes} bytes)");

        // per-struct functions
        emit_per_struct_functions(&mut code_snippets, &struct_name, struct_type)?;
        code_snippets.push(CSnippet::Newline);

        // per-struct-field functions
        for struct_field in struct_.get_children() {
            ensure!(
                struct_field.get_kind() == EntityKind::FieldDecl,
                "all fields of a struct must be of FieldDecl type"
            );

            // note down the origin of this error
            let error_note = format!("struct {struct_name:?}, field {struct_field:?}");

            let field_name = struct_field
                .get_name()
                .ok_or_eyre("unknown name")
                .section(error_note.clone())?;

            let (field_offset_bits, field_ty) = match (
                struct_type.get_offsetof(&field_name),
                struct_field.get_type(),
            ) {
                (Ok(fo), Some(ft)) => (fo, ft),
                _ => continue,
                // (Ok(_), None) => todo!(),
                // (Err(_), None) => todo!(),
                // (Err(_), Some(_)) => todo!(),
            };

            debug!(
                "    field: {:?} (offset: {} bits)",
                field_name, field_offset_bits
            );

            emit_per_field_functions(
                &mut code_snippets,
                &struct_name,
                &field_name,
                field_offset_bits,
                field_ty,
                endianness_swap,
            )?;
        }
        code_snippets.push(CSnippet::Newline);
    }

    code_snippets.push(CSnippet::Newline);

    debug!("done generating code, writing output");

    // assmeble the code
    let section_title_comment_width = 80;
    let spaces_per_tab = 4;

    // actually generate strings
    let mut code_snippet_strings: Vec<String> = code_snippets
        .iter()
        .map(|s| match s {
            CSnippet::Include(cinclude) => cinclude.generate(),
            CSnippet::Func(cfunc) => {
                cfunc.generate(comment, !only_prototype, function_decl_prefix.as_deref())
            }
            CSnippet::Section(csection) => csection.generate(section_title_comment_width),
            CSnippet::Newline => '\n'.into(),
        })
        .collect();

    // retab with spaces
    for snip in &mut code_snippet_strings {
        let tab_space_replacement = " ".repeat(spaces_per_tab);
        *snip = snip.replace('\t', &tab_space_replacement);

        // normalize newline endings
        if !snip.ends_with("\n") {
            snip.push('\n');
        }
    }

    // join it into a string
    let final_c_code = code_snippet_strings.concat();

    match output_file {
        // write to output file
        Some(output_file) => {
            let mut file = File::create(output_file)?;
            file.write_all(final_c_code.as_bytes())?;
        }
        // write to stdout
        None => println!("{final_c_code}"),
    }

    Ok(())
}

/// Function to insert the [`CSnippets`] for functiosn related to a given struct itself
fn emit_per_struct_functions(
    code_snippets: &mut Vec<CSnippet>,
    struct_name: &str,
    struct_type: clang::Type,
) -> Result<()> {
    let namespace_prefix = "cal";
    let function_name_gen = |op| format!("{namespace_prefix}_{op}__{struct_name}");

    let struct_size_bytes = struct_type.get_sizeof()?;

    // section header for this struct
    code_snippets.push(
        CSection {
            title: format!(" {struct_name} "),
            comment: Default::default(),
        }
        .into(),
    );
    code_snippets.push(CSnippet::Newline);

    // helper functions for size of the entire struct
    code_snippets.push(
        CFunc {
            comment: format!(
                "\
                `sizeof({struct_name})`\n\
                \n\
                Returns the size in bytes consumed for one instance of the `{struct_name}`\
            "
            ),
            return_type: RepresentableCType::UIntPtr,
            name: function_name_gen("sizeof"),
            arguments: vec![],
            body: format!("return {};", struct_size_bytes),
        }
        .into(),
    );
    code_snippets.push(CSnippet::Newline);

    Ok(())
}

/// Function to insert the [`CSnippets`] for all struct field related functions
fn emit_per_field_functions(
    code_snippets: &mut Vec<CSnippet>,
    struct_name: &str,
    field_name: &str,
    offset_bits: usize,
    ty: clang::Type,
    swap_endianness: bool,
) -> Result<()> {
    if offset_bits % 8 != 0 {
        bail!("bit offset which is not devisable by 8, this is not implemented yet");
    }

    let offset_bytes = offset_bits / 8;

    let namespace_prefix = "cal";
    let function_name_gen = |op| format!("{namespace_prefix}_{op}__{struct_name}__{field_name}");

    // desugar this type so that we know what it actually is
    let canonical_type = ty.get_canonical_type();

    // a couple of often reccuring C types
    let c_void_ptr_ty = RepresentableCType::Opaque { bytes: None };
    let c_u8_ty = RepresentableCType::Integer {
        bytes: 1,
        is_unsigned: true,
    };

    // find a platform agnostic representation of this type
    let generic_c_field_repr = RepresentableCType::new(&canonical_type)?;

    code_snippets.push(
        CSection {
            title: format!(" {struct_name}.{field_name} "),
            comment: Default::default(),
        }
        .into(),
    );
    code_snippets.push(CSnippet::Newline);

    // helper functions for size of the field
    code_snippets.push(
        CFunc {
            comment: format!("\
                `sizeof({struct_name}->{field_name})`\n\
                \n\
                Returns the size in bytes of the `{field_name}` field from the `{struct_name}` struct\
            "),
            return_type: RepresentableCType::UIntPtr,
            name: function_name_gen("sizeof"),
            arguments: vec![],
            body: format!("return {};", generic_c_field_repr.size_bytes()?), // TODO bug, this is wrong for arrays
        }
        .into(),
    );
    code_snippets.push(CSnippet::Newline);

    // helper functions for offset of the field withing the struct
    code_snippets.push(CFunc {
        comment: format!("\
            `offsetof({struct_name}, {field_name})`\n\
            \n\
             Get the offset in bytes of the `{field_name}` field from the start of a `{struct_name}` struct\
        "),
        return_type: RepresentableCType::UIntPtr,
        name: function_name_gen("offsetof"),
        arguments: vec![],
        body: format!("return {offset_bytes};"),
    }.into());
    code_snippets.push(CSnippet::Newline);

    // string to anounce the presence of byte-swapping
    let maybe_endianness_swapped = if swap_endianness {
        ", with endianness swapped"
    } else {
        ""
    };

    use TypeKind::*;
    match (canonical_type.get_kind(), canonical_type.get_element_type()) {
        // integer or float or pointer
        (
            CharS | CharU | SChar | UChar | Short | UShort | Int | UInt | Long | ULong | LongLong
            | ULongLong | Float | Double | Pointer | Enum,
            // TODO really do this for pointer and enum?
            _,
        ) => {
            let size_of_type_bytes = generic_c_field_repr.size_bytes()?;
            let byte_swap_fn = match size_of_type_bytes {
                1 => "".to_owned(),
                n @ 2 | n @ 4 | n @ 8 => format!("bswap_{}", 8 * n),
                n => {
                    bail!("unable to perform a byte swap for an integer that is {n} bytes wide")
                }
            };

            // getter for integer types
            code_snippets.insert(code_snippets.len() -2, CFunc {
                comment: format!("\
                    Get `{struct_name}.{field_name}`\n\
                    \n\
                    Returns the field `{field_name}`'s value from an instance of the `{struct_name}` struct{maybe_endianness_swapped}\
                "),
                return_type: generic_c_field_repr.clone(),
                name: function_name_gen("get"),
                arguments: [
                    (c_void_ptr_ty.clone(), "struct_base_addr".to_owned())
                ].into(),
                body: if swap_endianness {
                    format!("return {byte_swap_fn}(*({generic_c_field_repr}*)(({generic_c_field_repr}*) struct_base_addr + {offset_bytes}));")
                }else {
                    format!("return *({generic_c_field_repr}*)(({generic_c_field_repr}*) struct_base_addr + {offset_bytes});")
                }
            }.into());
            code_snippets.insert(code_snippets.len() - 2, CSnippet::Newline);

            // setter for integer types
            code_snippets.insert(code_snippets.len() -2, CFunc {
                comment: format!("\
                    Set `{struct_name}.{field_name}` to `value`\n\
                    \n\
                    Overwrites the field `{field_name}`'s value of an `{struct_name}` struct instance with `value`{maybe_endianness_swapped}\
                "),
                return_type: RepresentableCType::Void,
                name: function_name_gen("set"),
                arguments: [
                    (c_void_ptr_ty.clone(), "struct_base_addr".to_owned()),
                    (generic_c_field_repr.clone(), "value".to_owned())
                ].into(),
                body: if swap_endianness {
                    format!("*(({generic_c_field_repr}*) struct_base_addr + {offset_bytes}) = {byte_swap_fn}(value);")
                }else {
                    format!("*(({generic_c_field_repr}*) struct_base_addr + {offset_bytes}) = value;")
                }
            }.into());
            code_snippets.insert(code_snippets.len() - 2, CSnippet::Newline);
        }

        // for arrays whose element type is one byte in size we can just verbatim copy the elements
        // TODO be more elegant, add more representations than 1D of u8
        (ConstantArray, Some(_)) if generic_c_field_repr.size_element_bytes()? == 1 => {
            let total_bytes = generic_c_field_repr.size_bytes()? * generic_c_field_repr.length();

            let return_type = RepresentableCType::Array {
                element_type: Box::new(c_u8_ty),
                dimensional_lengths: vec![total_bytes],
            };
            let argument_type = return_type.clone();

            // getter for array types
            code_snippets.insert(code_snippets.len() -2, CFunc {
                comment: format!("\
                    Read from `{struct_name}.{field_name}`\n\
                    \n\
                    Copies from `{field_name}` field of an instance of the `{struct_name}` struct to `destination`\
                "),
                return_type: c_void_ptr_ty.clone(),
                name: function_name_gen("read"),
                arguments: [
                    (c_void_ptr_ty.clone(), "struct_base_addr".to_owned()),
                    (argument_type.clone(), generic_c_field_repr.format_as_type(Some("dst")))
                ].into(),
                body: format!("\
                    for(uintptr_t i = 0; i < {total_bytes}; i++)\n\
                    \tdst[i] = struct_base_addr[{offset_bytes} + i];\
                ")
            }.into());
            code_snippets.insert(code_snippets.len() - 2, CSnippet::Newline);

            // setter for array types
            code_snippets.insert(code_snippets.len() -2, CFunc {
                comment: format!("\
                    Write to `{struct_name}.{field_name}`\n\
                    \n\
                    Copies from `source` to the `{field_name}` field of an `{struct_name}` struct instance\
                "),
                return_type: RepresentableCType::Void,
                name: function_name_gen("write"),
                arguments: [
                    (c_void_ptr_ty.clone(), "struct_base_addr".to_owned()),
                    (argument_type.clone(), generic_c_field_repr.format_as_type(Some("src")))
                ].into(),
                body: format!("\
                    for(uintptr_t i = 0; i < {total_bytes}; i++)\n\
                    \tstruct_base_addr[{offset_bytes} + i] = src[i];\
                ")
            }.into());
            code_snippets.insert(code_snippets.len() - 2, CSnippet::Newline);
        }

        // we don't know what to do, so just hand out a void pointer
        (type_kind, maybe_type) => {
            // accessor via void ptr
            code_snippets.insert(code_snippets.len() -2, CFunc {
                comment: format!("\
                    Get void pointer to `{struct_name}.{field_name}`\n\
                    \n\
                    No ABI compatible representation of this type is known, therefore this just returns a void ptr\n\
                    \n\
                    type kind:  {type_kind:?}\n\
                    maybe type: {maybe_type:?}\
                "),
                return_type: c_void_ptr_ty.clone(),
                name: function_name_gen("get"),
                arguments: [
(                    c_void_ptr_ty.clone(), "struct_base_addr".to_owned()),
                ].into(),
                body: format!("return (void*)(struct_base_addr + {offset_bytes});")
            }.into());
            code_snippets.insert(code_snippets.len() - 2, CSnippet::Newline);
        }
    }

    Ok(())
}

/// Generic representation of a snippet of C-Code
pub enum CSnippet {
    Include(CInclude),
    Func(CFunc),
    Section(CSection),
    Newline,
}

impl From<CInclude> for CSnippet {
    fn from(value: CInclude) -> Self {
        Self::Include(value)
    }
}

impl From<CFunc> for CSnippet {
    fn from(value: CFunc) -> Self {
        Self::Func(value)
    }
}

impl From<CSection> for CSnippet {
    fn from(value: CSection) -> Self {
        Self::Section(value)
    }
}

/// Representation of an include
pub enum CInclude {
    /// Using `<...>`
    System(String),
    /// Using `"..."`
    Library(String),
}

impl CInclude {
    pub fn generate(&self) -> String {
        match self {
            Self::System(h) => format!("#include<{h}>\n"),
            Self::Library(h) => format!(r#"#include"{h}"\n"#),
        }
    }
}

/// Representation of a function in C
pub struct CFunc {
    pub comment: String,
    pub return_type: RepresentableCType,
    pub name: String,
    pub arguments: Vec<(RepresentableCType, String)>,
    pub body: String,
}

impl CFunc {
    /// Generate function code
    ///
    /// # Arguments
    ///
    /// - `emit_comment`: whether to also emit a comment explaining the function up-front
    /// - `emit_body`: whether to emit the body of the function, or only a prototyp/forward declartion of the function signature
    /// - `func_decl_prefix`: any possible function prefix to be emitted up front
    pub fn generate(
        &self,
        emit_comment: bool,
        emit_body: bool,
        func_decl_prefix: Option<&str>,
    ) -> String {
        let Self {
            return_type, name, ..
        } = self;

        let comment = if emit_comment {
            self.format_comment()
        } else {
            Default::default()
        };

        let prefix = Self::format_func_prefix(func_decl_prefix);

        let args = self.format_args();

        let body = if emit_body {
            format!("{{\n{}\n}}", self.format_body())
        } else {
            ";\n".to_owned()
        };

        format!("{comment}{prefix}{return_type} {name}({args}){body}")
    }

    /// Format a function prefix followed by a space, or an empty string
    fn format_func_prefix(maybe_prefix: Option<&str>) -> String {
        maybe_prefix.map(|x| format!("{x} ")).unwrap_or_default()
    }

    /// Formats a comment string into what C actually considers a comment (e.g. each line prefixed with `// `)
    fn format_comment(&self) -> String {
        let comment_token = "//";
        let newline = "\n";
        let space = " ";
        let mut result = String::new();
        for line in self.comment.lines() {
            result.push_str(comment_token);
            if !line.is_empty() {
                result.push_str(space);
                result.push_str(line);
            }
            result.push_str(newline);
        }
        result
    }

    /// Formats a function body
    ///
    /// No trailing newline
    fn format_body(&self) -> String {
        let indentation_token = "\t";
        let mut result = String::new();
        for line in self.body.lines() {
            if !line.is_empty() {
                result.push_str(indentation_token);
                result.push_str(line);
            }
        }
        result
    }

    /// Formats the arugments into an argument list
    fn format_args(&self) -> String {
        let arg_sep_token = ", ";
        let mut vec: Vec<_> = self
            .arguments
            .iter()
            .map(|(type_, name)| type_.format_as_type(Some(name)))
            .collect();

        // no argumnts? Then the function must have `void` in the parenthesis of the declaration!
        if vec.is_empty() {
            vec.push("void".to_owned());
        }

        vec.join(arg_sep_token)
    }
}

/// Representation of a section in C
pub struct CSection {
    pub title: String,
    pub comment: String,
}

impl CSection {
    /// Generate section code
    ///
    /// # Arguments
    ///
    /// - `emit_comment`: whether to also emit a comment explaining the function up-front
    /// - `emit_body`: whether to emit the body of the function, or only a prototyp/forward declartion of the function signature
    /// - `func_decl_prefix`: any possible function prefix to be emitted up front
    pub fn generate(&self, width: u16) -> String {
        let Self { title, comment } = self;
        let width = width as usize - 4;
        let mut result = format!("/*{title:*^width$}*/\n");

        if comment.is_empty() {
            return result;
        }
        result.push('/');

        for line in comment.lines() {
            result.push_str(&format!("* {line}\n "));
        }
        result.push_str("*/\n");

        result
    }
}
