use std::{fs::File, io::Write, path::PathBuf};

use c_types::{CByteArrayType, CIntegerStdintH, FormatToCType, UnrepresentableType};
use clang::*;

use clap::Parser;
use color_eyre::{
    Result, Section,
    eyre::{OptionExt, bail, ensure, eyre},
};
use log::debug;

mod c_types;

const TOOL_NAME: &str = env!("CARGO_BIN_NAME");
const TOOL_VERSION: &str = env!("CARGO_PKG_VERSION");

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Whether to perform an endianness swap
    ///
    /// If this flag is not set, endianness is never changed.
    /// If this flag is set, endianness of all primitive types longer than 1 byte is swapped.
    #[arg(short, long)]
    endianness_swap: bool,

    /// Input C file to consume
    ///
    /// Can be either a .c or a .h file.
    input_file: PathBuf,

    /// Output C file
    ///
    /// If not specified, instead the generated code is printed to the terminal's stdout
    #[arg(short, long)]
    output_file: Option<PathBuf>,

    /// Clang arguments
    ///
    /// These are passed through verbatim to (lib-)clang. Likely you want to set the target architecture here, e.g.
    ///
    /// -- --target=wasm32-unknown-none
    clang_args: Vec<String>,
}

fn main() -> Result<()> {
    // parse the CLI arguments
    let args = Cli::parse();

    // intialize logger
    colog::init();
    color_eyre::install()?;

    debug!("initializing clang");
    let clang = Clang::new().map_err(|e| eyre!("error initializing clang:\n{e}"))?;

    // Create a new `Index`
    let index = Index::new(&clang, false, false);

    // Parse a source file into a translation unit
    let mut parser = index.parser(&args.input_file);

    // Pass all clang args
    parser.arguments(&args.clang_args);

    // parse the code into a translation unit
    debug!("parsing {:?}", args.input_file);
    let tu = parser.parse()?;

    // get target information
    let target = tu.get_target();
    debug!("target: {target:?}");
    let Target {
        triple: target_triple,
        pointer_width: _target_pointer_width,
    } = target;

    // Get the structs in this translation unit
    let structs = tu
        .get_entity()
        .get_children()
        .into_iter()
        .filter(|e| e.get_kind() == EntityKind::StructDecl)
        .collect::<Vec<_>>();

    let mut c_code_snippets = Vec::new();

    c_code_snippets.push(format!(
        "\
        // THIS CODE IS AUTOGENERATED, DON'T MODIFY BY HAND\n\
        //\n\
        // This header-only library provides access to data type instances represented in\n\
        // a foreign architecture's ABI. In particular, it provides getter and setter\n\
        // functions for struct fields which observe the foreign architecture's memory\n\
        // layout.\n\
        //\n\
        // input_file ..... {:?}\n\
        // clang_args ..... {:?}\n\
        // target_arch .... {target_triple}\n\
        // generated_by ... {TOOL_NAME} v{TOOL_VERSION}\n\n\n\
        #include<stdint.h>\n\
        ",
        args.input_file, args.clang_args
    ));

    // if endianness swap is desired, include the header file for it
    if args.endianness_swap {
        c_code_snippets.push("#include<byteswap.h>".into());
    }

    c_code_snippets.push("\n\n".into());

    // Print information about the structs
    for struct_ in structs {
        let struct_ty = struct_.get_type().ok_or_eyre("struct type is unknown?!")?;
        let struct_size_bytes = struct_ty.get_sizeof()?;
        let struct_name = struct_.get_name().ok_or_eyre("struct has no name")?;
        debug!(
            "struct: {:?} (size: {} bytes)",
            struct_.get_name().unwrap(),
            struct_size_bytes
        );

        // code gen boilerplate
        let prefix = "inline";
        let namespace_prefix = "camw";
        let function_name_gen = |op| format!("{namespace_prefix}_{op}__{struct_name}");

        // section header for this struct
        let section_title = format!(" {struct_name} ");
        c_code_snippets.push(format!("/*{section_title:*^76}*/"));
        c_code_snippets.push("\n".into());

        let function_name = function_name_gen("sizeof");
        // helper functions for size of the entire struct
        c_code_snippets.push(format!(
            "\
            // `sizeof({struct_name})`\n\
            //\n\
            // Returns the size in bytes consumed for one instance of the `{struct_name}`\n\
            {prefix} uintptr_t {function_name}(){{\n\
            \treturn {struct_size_bytes};\n\
            }}\n\
            "
        ));

        c_code_snippets.push("\n\n".into());

        for struct_field in struct_.get_children() {
            ensure!(
                struct_field.get_kind() == EntityKind::FieldDecl,
                "all fields of a struct must be of FieldDecl type"
            );

            // note down the origin of this error
            let error_note = format!("struct {struct_name:?}, field {struct_field:?}");

            let field_name = struct_field
                .get_name()
                .ok_or_eyre("unknown name")
                .section(error_note.clone())?;

            let field_offset_bits = struct_ty
                .get_offsetof(&field_name)
                .map_err(|e| eyre!("unknown offset").error(e).section(error_note.clone()))?;

            let field_ty = struct_field
                .get_type()
                .ok_or_eyre("uknown type")
                .section(error_note.clone())?;

            debug!(
                "    field: {:?} (offset: {} bits)",
                field_name, field_offset_bits
            );

            let new_c_code_snippets = generate_getter_setter(
                &struct_name,
                &field_name,
                field_offset_bits,
                field_ty,
                args.endianness_swap,
            )?;

            c_code_snippets.push(new_c_code_snippets.join("\n\n"));
            c_code_snippets.push("\n\n".into());
        }
    }

    debug!("done generating code, writing output");

    for string in &mut c_code_snippets {
        // re-tab with spaces
        let spaces_per_tab = 2;
        let tab_space_replacement = " ".repeat(spaces_per_tab);
        *string = string.replace('\t', &tab_space_replacement);

        if !string.ends_with("\n") {
            string.push('\n');
        }
    }

    let final_c_code = c_code_snippets.concat();

    match args.output_file {
        // write to output file
        Some(output_file) => {
            let mut file = File::create(output_file)?;
            file.write_all(final_c_code.as_bytes())?;
        }
        // write to stdout
        None => println!("{final_c_code}"),
    }

    Ok(())
}

fn generate_getter_setter(
    struct_name: &str,
    field_name: &str,
    offset_bits: usize,
    ty: clang::Type,
    swap_endianness: bool,
) -> Result<Vec<String>> {
    if offset_bits % 8 != 0 {
        bail!("bit offset which is not devisable by 8, this is not implemented yet");
    }

    let offset_bytes = offset_bits / 8;

    let mut c_code_snippets = Vec::new();
    let mut c_funcs = Vec::with_capacity(4);

    let namespace_prefix = "camw";
    let function_name_gen = |op| format!("{namespace_prefix}_{op}__{struct_name}__{field_name}");
    let u8_ty = "uint8_t";

    let type_formatter: Box<dyn FormatToCType>;

    // desugar this type so that we know what it actually is
    let canonical_type = ty.get_canonical_type();

    let section_title = format!(" {struct_name}.{field_name} ");
    c_code_snippets.push(format!("/*{section_title:*^76}*/"));

    // string to anounce the presence of byte-swapping
    let maybe_endianness_swapped = if swap_endianness {
        ", with endianness swapped"
    } else {
        ""
    };

    use TypeKind::*;
    match (canonical_type.get_kind(), canonical_type.get_element_type()) {
        // integer or float or pointer
        (
            CharS | CharU | SChar | UChar | Short | UShort | Int | UInt | Long | ULong | LongLong
            | ULongLong | Float | Double | Pointer | Enum,
            _,
        ) => {
            type_formatter = Box::new(CIntegerStdintH::new(canonical_type)?);
            let return_type = type_formatter.to_function_return_type();
            let argument_type = type_formatter.to_function_argument_type("value");

            let size_of_type_bytes = type_formatter.size_bytes();
            let byte_swap_fn = match size_of_type_bytes {
                1 => "".to_string(),
                n @ 2 | n @ 4 | n @ 8 => format!("bswap_{}", 8 * n),
                n => {
                    bail!("unable to perform a byte swap for an integer that is is {n} bytes wide")
                }
            };

            // getter for integer types
            c_funcs.push(CFunc {
                comment: format!("\
                    Get `{struct_name}.{field_name}`\n\
                    \n\
                    Returns the field `{field_name}`'s value from an instance of the `{struct_name}` struct{maybe_endianness_swapped}\
                "),
                return_type: return_type.clone(),
                name: function_name_gen("get"),
                arguments: [
                    format!("{u8_ty} * struct_base_addr")
                ].into(),
                body: if swap_endianness {
                    format!("return {byte_swap_fn}(*({return_type}*)(struct_base_addr + {offset_bytes}));")
                }else {
                    format!("return *({return_type}*)(struct_base_addr + {offset_bytes});")
                }
            });

            // setter for integer types
            c_funcs.push(CFunc {
                comment: format!("\
                    Set `{struct_name}.{field_name}` to `value`\n\
                    \n\
                    Overwrites the field `{field_name}`'s value of an `{struct_name}` struct instance with `value`{maybe_endianness_swapped}\
                "),
                return_type: "void".into(),
                name: function_name_gen("set"),
                arguments: [
                    format!("{u8_ty} * struct_base_addr"),
                    argument_type
                ].into(),
                body: if swap_endianness {
                    format!("*(struct_base_addr + {offset_bytes}) = {byte_swap_fn}(value);")
                }else {
                    format!("*(struct_base_addr + {offset_bytes}) = value;")
                }
            });
        }

        // for arrays whose element type is one byte in size we can just verbatim copy the elements
        (ConstantArray, Some(element_ty)) if element_ty.get_sizeof() == Ok(1) => {
            type_formatter = Box::new(CByteArrayType::new(canonical_type)?);
            let size_of_type_bytes = type_formatter.size_bytes();

            // getter for array types
            c_funcs.push(CFunc {
                comment: format!("\
                    Read from `{struct_name}.{field_name}`\n\
                    \n\
                    Copies from `{field_name}` field of an instance of the `{struct_name}` struct to `destination`\
                "),
                return_type: "void".into(),
                name: function_name_gen("read"),
                arguments: [
                    format!("{u8_ty} * struct_base_addr"),
                    type_formatter.to_function_argument_type("dst")
                ].into(),
                body: format!("\
                    for(uintptr_t i = 0; i < {size_of_type_bytes}; i++)\n\
                    \tdst[i] = struct_base_addr[{offset_bytes} + i];\n\
                ")
            });

            // setter for array types
            c_funcs.push(CFunc {
                comment: format!("\
                    Write to `{struct_name}.{field_name}`\n\
                    \n\
                    Copies from `source` to the `{field_name}` field of an `{struct_name}` struct instance\
                "),
                return_type: "void".into(),
                name: function_name_gen("write"),
                arguments: [
                    format!("{u8_ty} * struct_base_addr"),
                    type_formatter.to_function_argument_type("src")
                ].into(),
                body: format!("\
                    for(uintptr_t i = 0; i < {size_of_type_bytes}; i++)\n\
                    \tstruct_base_addr[{offset_bytes} + i] = src[i];\
                ")
            });
        }

        // we don't know what to do, so just hand out a void pointer
        (type_kind, maybe_type) => {
            type_formatter = Box::new(UnrepresentableType{ type_kind, maybe_type});

            // accessor via void ptr
            c_funcs.push(CFunc {
                comment: format!("\
                    Get void pointer to `{struct_name}.{field_name}`\n\
                    \n\
                    No ABI compatible representation of this type is known, therefore this just returns a void ptr\n\
                    \n\
                    type kind:  {type_kind:?}\n\
                    maybe type: {maybe_type:?}\
                "),
                return_type: "void *".into(),
                name: function_name_gen("get"),
                arguments: [
                    format!("{u8_ty} * struct_base_addr"),
                ].into(),
                body: format!("return (void*)(struct_base_addr + {offset_bytes});")
            });
        }
    }

    // helper functions for size of the field
    c_funcs.push(CFunc {
        comment: format!(
            "\
            `sizeof({struct_name}->{field_name})`\n\
            \n\
            Returns the size in bytes of the `{field_name}` field from the `{struct_name}` struct\
        "
        ),
        return_type: "uintptr_t".into(),
        name: function_name_gen("sizeof"),
        arguments: vec![],
        body: format!("return {};", type_formatter.size_bytes()),
    });

    // helper functions for offset of the field withing the struct
    c_funcs.push(CFunc {
        comment: format!("\
            `offsetof({struct_name}, {field_name})`\n\
            \n\
             Get the offset in bytes of the `{field_name}` field from the start of a `{struct_name}` struct\
        "),
        return_type: "uintptr_t".into(),
        name: function_name_gen("offsetof"),
        arguments: vec![],
        body: format!("return {offset_bytes};"),
    });

    // concat all the function declarations
    for c_func in c_funcs {
        // println!("{:#?}", c_func.gen_inline_implementation().unwrap());
        // println!("{}", c_func.gen_inline_implementation().unwrap());
        c_code_snippets.push(c_func.gen_inline_implementation()?);
    }

    Ok(c_code_snippets)
}

/// Representation of a C-Function
struct CFunc {
    pub comment: String,
    pub return_type: String, //Box<dyn FormatToCType>,
    pub name: String,
    pub arguments: Vec<String>,
    pub body: String,
}

impl CFunc {
    /// Generate prototype (declaration) for this function
    pub fn gen_prototype(&self) -> Result<String> {
        let Self {
            return_type, name, ..
        } = self;
        let comment = self.format_comment();
        let args = self.format_args();
        Ok(format!("{comment}{return_type} {name}({args});"))
    }

    /// Generate implementation for this function
    pub fn gen_implementation(&self) -> Result<String> {
        let Self {
            return_type, name, ..
        } = self;
        let args = self.format_args();
        let body = self.format_body();
        Ok(format!("{return_type} {name}({args}){{\n{body}\n}}"))
    }

    /// Generate inline implementation for this function
    pub fn gen_inline_implementation(&self) -> Result<String> {
        let Self {
            return_type, name, ..
        } = self;
        let comment = self.format_comment();
        let args = self.format_args();
        let body = self.format_body();
        Ok(format!(
            "{comment}inline {return_type} {name}({args}){{\n{body}}}"
        ))
    }

    /// Formats a comment string into what C actually considers a comment (e.g. each line prefixed with `// `)
    fn format_comment(&self) -> String {
        let comment_token = "//";
        let newline = "\n";
        let space = " ";
        let mut result = String::new();
        for line in self.comment.lines() {
            result.push_str(comment_token);
            if !line.is_empty() {
                result.push_str(space);
                result.push_str(line);
            }
            result.push_str(newline);
        }
        result
    }

    /// Formats a function body
    fn format_body(&self) -> String {
        let indentation_token = "\t";
        let newline = "\n";
        let mut result = String::new();
        for line in self.body.lines() {
            if !line.is_empty() {
                result.push_str(indentation_token);
                result.push_str(line);
            }
            result.push_str(newline);
        }
        result
    }

    /// Formats the arugments into an argument list
    fn format_args(&self) -> String {
        let arg_sep_token = ", ";
        let vec: Vec<_> = self.arguments.iter().map(|a| a.to_string()).collect();
        vec.join(arg_sep_token)
    }
}

struct CFuncArg {
    type_: Box<dyn FormatToCType>,
    name: String,
}

impl CFuncArg {
    fn new<T: Into<Box<dyn FormatToCType>>, U: Into<String>>(type_: T, name: U) -> Self {
        Self {
            type_: type_.into(),
            name: name.into(),
        }
    }
}

impl std::fmt::Display for CFuncArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.type_.to_function_argument_type(&self.name))
    }
}
