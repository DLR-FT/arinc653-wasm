use std::{fs::File, io::Write, path::PathBuf};

use c_types::{CByteArrayType, CIntegerStdintH, FormatToCType};
use clang::*;

use clap::Parser;
use color_eyre::{
    Result, Section,
    eyre::{OptionExt, bail, ensure, eyre},
};
use log::{debug, warn};

mod c_types;

const TOOL_NAME: &str = env!("CARGO_BIN_NAME");
const TOOL_VERSION: &str = env!("CARGO_PKG_VERSION");

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Whether to perform an endianness swap
    ///
    /// If this flag is not set, endianness is never changed.
    /// If this flag is set, endianness of all primitive types longer than 1 byte is swapped.
    #[arg(short, long)]
    endianness_swap: bool,

    /// Input C file to consume
    ///
    /// Can be either a .c or a .h file.
    input_file: PathBuf,

    /// Output C file
    ///
    /// If not specified, instead the generated code is printed to the terminal's stdout
    #[arg(short, long)]
    output_file: Option<PathBuf>,

    /// Clang arguments
    ///
    /// These are passed through verbatim to (lib-)clang. Likely you want to set the target architecture here, e.g.
    ///
    /// -- --target=wasm32-unknown-none
    clang_args: Vec<String>,
}

fn main() -> Result<()> {
    // parse the CLI arguments
    let args = Cli::parse();

    // intialize logger
    colog::init();
    color_eyre::install()?;

    debug!("initializing clang");
    let clang = Clang::new().map_err(|e| eyre!("error initializing clang:\n{e}"))?;

    // Create a new `Index`
    let index = Index::new(&clang, false, false);

    // Parse a source file into a translation unit
    let mut parser = index.parser(&args.input_file);

    // Pass all clang args
    parser.arguments(&args.clang_args);

    // parse the code into a translation unit
    debug!("parsing {:?}", args.input_file);
    let tu = parser.parse()?;

    // get target information
    let target = tu.get_target();
    debug!("target: {target:?}");
    let Target {
        triple: target_triple,
        pointer_width: _target_pointer_width,
    } = target;

    // Get the structs in this translation unit
    let structs = tu
        .get_entity()
        .get_children()
        .into_iter()
        .filter(|e| e.get_kind() == EntityKind::StructDecl)
        .collect::<Vec<_>>();

    let mut c_code_snippets = Vec::new();

    c_code_snippets.push(format!(
        "\
        // THIS CODE IS AUTOGENERATED, DON'T MODIFY BY HAND\n\
        //\n\
        // This header-only library provides access to data type instances represented in\n\
        // a foreign architecture's ABI. In particular, it provides getter and setter\n\
        // functions for struct fields which observe the foreign architecture's memory\n\
        // layout.\n\
        //\n\
        // input_file ..... {:?}\n\
        // clang_args ..... {:?}\n\
        // target_arch .... {target_triple}\n\
        // generated_by ... {TOOL_NAME} v{TOOL_VERSION}\n\n\n\
        #include<stdint.h>\n\
        ",
        args.input_file, args.clang_args
    ));

    // if endianness swap is desired, include the header file for it
    if args.endianness_swap {
        c_code_snippets.push("#include<byteswap.h>".into());
    }

    c_code_snippets.push("\n\n".into());

    // Print information about the structs
    for struct_ in structs {
        let struct_ty = struct_.get_type().ok_or_eyre("struct type is unknown?!")?;
        let struct_size_bytes = struct_ty.get_sizeof()?;
        let struct_name = struct_.get_name().ok_or_eyre("struct has no name")?;
        debug!(
            "struct: {:?} (size: {} bytes)",
            struct_.get_name().unwrap(),
            struct_size_bytes
        );

        // code gen boilerplate
        let prefix = "inline";
        let namespace_prefix = "camw";
        let function_name_gen = |op| format!("{namespace_prefix}_{op}__{struct_name}");

        // section header for this struct
        let section_title = format!(" {struct_name} ");
        c_code_snippets.push(format!("/*{section_title:*^76}*/"));
        c_code_snippets.push("\n".into());

        // print a table overview of the struct members
        c_code_snippets.push("/* Struct overview\n".into());

        let struct_align = struct_ty.get_alignof()?;
        c_code_snippets.push(format!(" *\n * size = {struct_size_bytes} ({struct_size_bytes:#x}), align = {struct_align:#x}\n *\n"));

        let mut member_overview_table = vec![vec!["field".into(), "offset".into(), "size".into()]];

        for field in struct_.get_children() {
            let field_name = field.get_name().ok_or_eyre("unknown name")?;
            let field_offset = struct_ty.get_offsetof(&field_name)? / 8;
            let field_size = field.get_type().ok_or_eyre("uknown type")?.get_sizeof()?;

            member_overview_table.push(vec![
                field_name,
                format!("{field_offset} ({field_offset:#x})"),
                format!("{field_size} ({field_size:#x})"),
            ]);
        }
        let md_table = generate_md_table(member_overview_table);
        for line in md_table {
            c_code_snippets.push(format!(" * {line}\n"));
        }

        c_code_snippets.push(" */\n\n".into());

        // start of actual access functions
        let function_name = function_name_gen("sizeof");
        // helper functions for size of the entire struct
        c_code_snippets.push(format!(
            "\
            // `sizeof({struct_name})`\n\
            //\n\
            // Returns the size in bytes consumed for one instance of the `{struct_name}`\n\
            {prefix} uintptr_t {function_name}(){{\n\
            \treturn {struct_size_bytes};\n\
            }}\n\
            "
        ));

        c_code_snippets.push("\n\n".into());

        for struct_field in struct_.get_children() {
            ensure!(
                struct_field.get_kind() == EntityKind::FieldDecl,
                "all fields of a struct must be of FieldDecl type"
            );

            // note down the origin of this error
            let error_note = format!("struct {struct_name:?}, field {struct_field:?}");

            let field_name = struct_field
                .get_name()
                .ok_or_eyre("unknown name")
                .section(error_note.clone())?;

            let field_offset_bits = struct_ty
                .get_offsetof(&field_name)
                .map_err(|e| eyre!("unknown offset").error(e).section(error_note.clone()))?;

            let field_ty = struct_field
                .get_type()
                .ok_or_eyre("uknown type")
                .section(error_note.clone())?;

            debug!(
                "    field: {:?} (offset: {} bits)",
                field_name, field_offset_bits
            );

            let new_c_code_snippets = generate_getter_setter(
                &struct_name,
                &field_name,
                field_offset_bits,
                field_ty,
                args.endianness_swap,
            )?;

            c_code_snippets.push(new_c_code_snippets.join("\n\n"));
            c_code_snippets.push("\n\n".into());
        }
    }

    debug!("done generating code, writing output");

    for string in &mut c_code_snippets {
        // re-tab with spaces
        let spaces_per_tab = 2;
        let tab_space_replacement = " ".repeat(spaces_per_tab);
        *string = string.replace('\t', &tab_space_replacement);

        if !string.ends_with("\n") {
            string.push('\n');
        }
    }

    let final_c_code = c_code_snippets.concat();

    match args.output_file {
        // write to output file
        Some(output_file) => {
            let mut file = File::create(output_file)?;
            file.write_all(final_c_code.as_bytes())?;
        }
        // write to stdout
        None => println!("{final_c_code}"),
    }

    Ok(())
}

fn generate_getter_setter(
    struct_name: &str,
    field_name: &str,
    offset_bits: usize,
    ty: clang::Type,
    swap_endianness: bool,
) -> Result<Vec<String>> {
    if offset_bits % 8 != 0 {
        bail!("bit offset which is not devisable by 8, this is not implemented yet");
    }

    let offset_bytes = offset_bits / 8;

    let mut c_code_snippets = Vec::new();

    let prefix = "inline";
    let namespace_prefix = "camw";
    let function_name_gen =
        |op| format!("{namespace_prefix}_{op}__{struct_name}__{field_name}");
    let u8 = "uint8_t";

    let type_formatter: Box<dyn FormatToCType>;

    // desugar this type so that we know what it actually is
    let canonical_type = ty.get_canonical_type();

    let section_title = format!(" {struct_name}.{field_name} ");
    c_code_snippets.push(format!("/*{section_title:*^76}*/"));

    use TypeKind::*;
    match (canonical_type.get_kind(), canonical_type.get_element_type()) {
        // integer or float or pointer
        (
            CharS | CharU | SChar | UChar | Short | UShort | Int | UInt | Long | ULong | LongLong
            | ULongLong | Float | Double | Pointer | Enum,
            _,
        ) => {
            type_formatter = Box::new(CIntegerStdintH::new(canonical_type)?);
            let return_type = type_formatter.to_function_return_type();
            let argument_type = type_formatter.to_function_argument_type("value");

            if swap_endianness {
                let size_of_type_bytes = type_formatter.size_bytes();
                let byte_swap_fn = match size_of_type_bytes {
                    1 => "".to_string(),
                    n @ 2 | n @ 4 | n @ 8 => format!("bswap_{}", 8 * n),
                    n => {
                        bail!(
                            "unable to perform a byte swap for an integer that is is {n} bytes wide"
                        )
                    }
                };

                let function_name = function_name_gen("get");
                // getter for integer types
                c_code_snippets.push(format!("\
            // Get `{struct_name}.{field_name}`\n\
            //\n\
            // Returns the field `{field_name}`'s value from an instance of the `{struct_name}` struct, with endianness swapped\n\
            {prefix} {return_type} {function_name}({u8} * struct_base_addr) {{\n\
            \treturn {byte_swap_fn}(*({return_type}*)(struct_base_addr + {offset_bytes}));\n\
            }}"));

                let function_name = function_name_gen("set");
                // setter for integer types
                c_code_snippets.push(format!("\
            // Set `{struct_name}.{field_name}` to `value`\n\
            // \n\
            // Overwrites the field `{field_name}`'s value of an `{struct_name}` struct instance with `value`, with endianness swapped\n\
            {prefix} void {function_name}({u8} * struct_base_addr, {argument_type}) {{\n\
            \t*(struct_base_addr + {offset_bytes}) = {byte_swap_fn}(value);\n\
            }}"));
            } else {
                let function_name = function_name_gen("get");
                // getter for integer types
                c_code_snippets.push(format!("\
            // Get `{struct_name}.{field_name}`\n\
            //\n\
            // Returns the field `{field_name}`'s value from an instance of the `{struct_name}` struct\n\
            {prefix} {return_type} {function_name}({u8} * struct_base_addr) {{\n\
            \treturn *({return_type}*)(struct_base_addr + {offset_bytes});\n\
            }}"));

                let function_name = function_name_gen("set");
                // setter for integer types
                c_code_snippets.push(format!("\
            // Set `{struct_name}.{field_name}` to `value`\n\
            // \n\
            // Overwrites the field `{field_name}`'s value of an `{struct_name}` struct instance with `value`\n\
            {prefix} void {function_name}({u8} * struct_base_addr, {argument_type}) {{\n\
            \t*(struct_base_addr + {offset_bytes}) = value;\n\
            }}"));
            }
        }

        // for arrays whose element type is one byte in size we can just verbatim copy
        (ConstantArray, Some(element_ty)) if element_ty.get_sizeof() == Ok(1) => {
            type_formatter = Box::new(CByteArrayType::new(canonical_type)?);
            let argument_type_dst = type_formatter.to_function_argument_type("dst");
            let argument_type_src = type_formatter.to_function_argument_type("src");
            let size_of_type_bytes = type_formatter.size_bytes();

            let function_name = function_name_gen("read");
            // getter for array types
            c_code_snippets.push(format!("\
                // Read from `{struct_name}.{field_name}`\n\
                //\n\
                // Copies from `{field_name}` field of an instance of the `{struct_name}` struct to `destination`\n\
                {prefix} void {function_name}({u8} * struct_base_addr, {argument_type_dst}) {{\n\
                \tfor(uintptr_t i = 0; i < {size_of_type_bytes}; i++)\n\
                \t\tdst[i] = struct_base_addr[{offset_bytes} + i];\n\
                }}"));

            let function_name = function_name_gen("write");
            // setter for array types
            c_code_snippets.push(format!("\
                // Write to `{struct_name}.{field_name}`\n\
                //\n\
                // Copies from `source` to the `{field_name}` field of an `{struct_name}` struct instance\n\
                {prefix} void {function_name}({u8} * struct_base_addr, {argument_type_src}) {{\n\
                \tfor(uintptr_t i = 0; i < {size_of_type_bytes}; i++)\n\
                \t\tstruct_base_addr[{offset_bytes} + i] = src[i];\n\
                }}"));
        }

        // TODO for array whose element types are larger than one byte in size, endian-ness swap eacht element
        (Record, _) => {
            // TODO just return a pointer to this records offset
            return Ok(vec![]);
        }

        // we don't know what to do
        x => {
            warn!(
                "don't know how to represent types of \"{x:?}\" kind\n\
                elaborated type:  {ty:?}\n\
                canonical type:   {canonical_type:?}"
            );
            return Ok(vec![]);
        }
    }

    let function_name = function_name_gen("sizeof");
    // helper functions for size of the field
    c_code_snippets.push(format!(
        "\
        // sizeof(`{struct_name}->{field_name})`\n\
        //\n\
        // Returns the size in bytes of the `{field_name}` field from the `{struct_name}` struct\n\
        {prefix} uintptr_t {function_name}() {{\n\
        \treturn {};\n\
        }}",
        type_formatter.size_bytes()
    ));

    let function_name = function_name_gen("offsetof");
    // helper functions for offset of the field withing the struct
    c_code_snippets.push(format!("\
        // `offsetof({struct_name}, {field_name})`\n\
        //\n\
        // Get the offset in bytes of the `{field_name}` field from the start of a `{struct_name}` struct\n\
        {prefix} uintptr_t {function_name}() {{\n\
        \treturn {offset_bytes};\n\
        }}",
    ));

    Ok(c_code_snippets)
}

fn generate_md_table(mut data: Vec<Vec<String>>) -> Vec<String> {
    let mut lines = Vec::with_capacity(data.len() + 1);

    let num_cols = data.iter().map(Vec::len).max().unwrap_or(0);
    let mut max_column_widths = vec![0; num_cols];

    // determine the maximum width of each column by
    for row in &data {
        for (max, current) in max_column_widths.iter_mut().zip(row.iter()) {
            *max = std::cmp::max(*max, current.len())
        }
    }

    // assemble the lines making up this table
    for (row_idx, row) in data.iter_mut().enumerate() {
        // cells are separated by this str
        let sep = " | ";

        // after the 0th and before the 1st row print the hline separating table header from body
        if row_idx == 1 {
            let header_hlines: Vec<String> = max_column_widths
                .iter()
                .map(|desired_width| "-".repeat(*desired_width))
                .collect();
            lines.push(header_hlines.join(sep));
        }

        // emit all the rows making up the table
        for (col_idx, cell) in row.iter_mut().enumerate() {
            let desired_width = max_column_widths[col_idx];
            // first col is left aligned, all other right aligned
            *cell = if col_idx == 0 {
                format!("{cell:<desired_width$}")
            } else {
                format!("{cell:>desired_width$}")
            };
        }
        lines.push(row.join(sep));
    }

    lines
}
